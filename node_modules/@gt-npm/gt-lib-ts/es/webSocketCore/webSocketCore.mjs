import { EventDispatcherCore } from '../eventDispatcher/index.mjs';
import { Logger } from '../logger/index.mjs';

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var WebSocketEvent = /* @__PURE__ */ ((WebSocketEvent2) => {
  WebSocketEvent2["NET_STATUS"] = "NET_STATUS";
  WebSocketEvent2["NET_RESULT"] = "NET_RESULT";
  return WebSocketEvent2;
})(WebSocketEvent || {});
class WebSocketCore extends EventDispatcherCore {
  constructor() {
    super(...arguments);
    __publicField(this, "ws");
    __publicField(this, "path", "");
    __publicField(this, "useCrypto");
    __publicField(this, "useBinary", false);
    __publicField(this, "protocolMap");
  }
  ab2str(arraybuffer) {
    const array = new Uint8Array(arraybuffer);
    let out = "", i = 0, len = array.length, c, char2, char3;
    while (i < len) {
      c = array[i++];
      switch (c >> 4) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
          out += String.fromCharCode(c);
          break;
        case 12:
        case 13:
          char2 = array[i++];
          out += String.fromCharCode((c & 31) << 6 | char2 & 63);
          break;
        case 14:
          char2 = array[i++];
          char3 = array[i++];
          out += String.fromCharCode((c & 15) << 12 | (char2 & 63) << 6 | char3 & 63);
          break;
      }
    }
    return out;
  }
  str2ab(str) {
    const n = str.length;
    let idx = -1;
    let byteLength = 512;
    let bytes = new Uint8Array(byteLength);
    for (let i = 0; i < n; ++i) {
      const c = str.charCodeAt(i);
      if (c <= 127) {
        bytes[++idx] = c;
      } else if (c <= 2047) {
        bytes[++idx] = 192 | c >>> 6;
        bytes[++idx] = 128 | c & 63;
      } else if (c <= 65535) {
        bytes[++idx] = 224 | c >>> 12;
        bytes[++idx] = 128 | c >>> 6 & 63;
        bytes[++idx] = 128 | c & 63;
      } else {
        bytes[++idx] = 240 | c >>> 18;
        bytes[++idx] = 128 | c >>> 12 & 63;
        bytes[++idx] = 128 | c >>> 6 & 63;
        bytes[++idx] = 128 | c & 63;
      }
      if (byteLength - idx <= 4) {
        const _bytes = bytes;
        byteLength *= 2;
        bytes = new Uint8Array(byteLength);
        bytes.set(_bytes);
      }
    }
    return bytes.subarray(0, ++idx);
  }
  deserialize(e) {
    var _a, _b;
    const data = e.data;
    const str = data instanceof ArrayBuffer ? this.ab2str(data) : data;
    const decryptedStr = (_b = (_a = this.useCrypto) == null ? void 0 : _a.decrypt(str)) != null ? _b : str;
    try {
      return JSON.parse(decryptedStr);
    } catch (error) {
      Logger.error("WebSocket deserialize JSON Data Error >>", error);
      return null;
    }
  }
  serializer(data) {
    var _a, _b;
    const str = typeof data !== "string" ? JSON.stringify(data) : data;
    const encryptedStr = (_b = (_a = this.useCrypto) == null ? void 0 : _a.encrypt(str)) != null ? _b : str;
    return this.useBinary ? this.str2ab(encryptedStr) : encryptedStr;
  }
  initWebSocket(path) {
    var _a, _b;
    Logger.log(`[WebSocketCore] start connect to ${path} using ${this.useBinary ? "arraybuffer" : "string"} protocol`);
    if (this.useBinary) {
      this.ws = new WebSocket(path, (_a = this.protocolMap) == null ? void 0 : _a.BINARY);
      this.ws.binaryType = "arraybuffer";
    } else {
      this.ws = new WebSocket(path, (_b = this.protocolMap) == null ? void 0 : _b.STRING);
    }
    this.ws.onopen = (e) => this.wsHandler(e);
    this.ws.onclose = (e) => this.wsHandler(e);
    this.ws.onmessage = (e) => this.wsHandler(e);
    this.ws.onerror = (e) => this.wsHandler(e);
  }
  wsHandler(event) {
    switch (event.type) {
      case "open":
      case "close":
      case "error":
        this.wsStatusHandler(event);
        break;
      case "message":
        this.wsMessageHandler(event);
        break;
    }
  }
  wsStatusHandler(rawEvent) {
    this.dispatchEvent("NET_STATUS" /* NET_STATUS */, {
      status: rawEvent.type,
      code: rawEvent instanceof CloseEvent ? rawEvent.code.toString() : ""
    });
  }
  wsMessageHandler(event) {
    const wsResponse = this.deserialize(event);
    this.dispatchEvent("NET_RESULT" /* NET_RESULT */, { result: wsResponse });
  }
  callServer(data) {
    var _a;
    Logger.log("[CallServer]", data);
    const payload = this.serializer(data);
    if (((_a = this.ws) == null ? void 0 : _a.readyState) === WebSocket.OPEN) {
      this.ws.send(payload);
    }
  }
  setupWs({
    useBinary,
    useCrypto,
    protocolMap
  }) {
    useBinary !== void 0 && (this.useBinary = useBinary);
    useCrypto !== void 0 && (this.useCrypto = useCrypto);
    protocolMap !== void 0 && (this.protocolMap = protocolMap);
  }
  connect(path) {
    if (!this.ws) {
      this.path = path;
      this.initWebSocket(path);
    }
  }
  reconnect() {
    if (this.ws) {
      switch (this.ws.readyState) {
        case WebSocket.OPEN:
          this.ws.close();
          break;
        case WebSocket.CLOSED:
          this.ws = void 0;
          this.connect(this.path);
          break;
      }
    } else {
      this.connect(this.path);
    }
  }
  close() {
    if (this.ws) {
      this.ws.close();
      this.ws = void 0;
    }
  }
}

export { WebSocketCore, WebSocketEvent };
//# sourceMappingURL=webSocketCore.mjs.map
