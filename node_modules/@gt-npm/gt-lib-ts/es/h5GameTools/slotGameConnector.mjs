import { useGlobalEventDispatcher } from '../eventDispatcher/index.mjs';
import { Logger } from '../logger/index.mjs';
import { DetectDevice } from '../utils/detectDevice.mjs';
import '../webSocketCore/index.mjs';
import { CommonStore } from './commonStore/index.mjs';
import { Comm } from './gtCommEvents.mjs';
import { UrlHelper } from './urlHelper.mjs';
import { LoadingInfo, TimeLabelKeys } from './userAnalysis/loadingInfo.mjs';
import { WebSocketCore, WebSocketEvent } from '../webSocketCore/webSocketCore.mjs';
import { AESCrypto } from '../webSocketCore/aesCrypto.mjs';

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var SlotGameEvent = /* @__PURE__ */ ((SlotGameEvent2) => {
  SlotGameEvent2["CLOSE"] = "slotGameEvent_close";
  SlotGameEvent2["CONNECTED"] = "slotGameEvent_connected";
  SlotGameEvent2["RECONNECTED"] = "slotGameEvent_reconnected";
  SlotGameEvent2["READY"] = "slotGameEvent_ready";
  SlotGameEvent2["UPDATE_JP"] = "slotGameEvent_updateJP";
  SlotGameEvent2["UPDATE_MARQUEE"] = "slotGameEvent_updateMarquee";
  SlotGameEvent2["LOGIN"] = "slotGameEvent_onLogin";
  SlotGameEvent2["TAKE_MACHINE"] = "slotGameEvent_onTakeMachine";
  SlotGameEvent2["LOAD_INFO"] = "slotGameEvent_onOnLoadInfo2";
  SlotGameEvent2["GET_MACHINE_LIST"] = "slotGameEvent_onGetMachineList";
  SlotGameEvent2["GET_MACHINE_DETAIL"] = "slotGameEvent_onGetMachineDetail";
  SlotGameEvent2["CREDIT_EXCHANGE"] = "slotGameEvent_onCreditExchange";
  SlotGameEvent2["BALANCE_EXCHANGE"] = "slotGameEvent_onBalanceExchange";
  SlotGameEvent2["HIT_JACKPOT"] = "slotGameEvent_onHitJackpot";
  SlotGameEvent2["BEGIN_GAME"] = "slotGameEvent_onBeginGame";
  SlotGameEvent2["DOUBLE_GAME"] = "slotGameEvent_onDoubleGame";
  SlotGameEvent2["END_GAME"] = "slotGameEvent_onEndGame";
  SlotGameEvent2["HIT_BONUS"] = "slotGameEvent_onHitBonus";
  SlotGameEvent2["END_BONUS"] = "slotGameEvent_onEndBonus";
  SlotGameEvent2["KEEP_MACHINE_STATUS"] = "slotGameEvent_onKeepMachineStatus";
  SlotGameEvent2["MACHINE_LEAVE"] = "slotGameEvent_machineLeave";
  return SlotGameEvent2;
})(SlotGameEvent || {});
class SlotGameConnector {
  constructor() {
    __publicField(this, "wsCore");
    __publicField(this, "closeConnectionByUser", false);
    __publicField(this, "useEncryption", false);
    this.init();
  }
  static get shared() {
    var _a, _b;
    if ((_a = window.gtLibTsScope) == null ? void 0 : _a.slotGameConnector) {
      return window.gtLibTsScope.slotGameConnector;
    }
    return ((_b = window.gtLibTsScope) != null ? _b : window.gtLibTsScope = {}).slotGameConnector = new SlotGameConnector();
  }
  init() {
    this.wsCore = new WebSocketCore();
    this.wsCore.setupWs({
      protocolMap: {
        BINARY: "casino.bin",
        STRING: "casino.op"
      }
    });
    this.wsCore.addEventListener(WebSocketEvent.NET_STATUS, (e) => this.wsStatusHandler(e));
    this.getEventDispatcher().addEventListener("updateUserAnalysis", (e) => {
      this.callUpdateUserAnalysis(e);
    });
  }
  getEventDispatcher() {
    return useGlobalEventDispatcher();
  }
  wsStatusHandler(event) {
    Logger.log(`[NetStatus]::${event.status}`);
    switch (event.status) {
      case "open":
        LoadingInfo.shared.push(TimeLabelKeys.ws);
        this.getEventDispatcher().dispatchEvent("slotGameEvent_connected" /* CONNECTED */, {
          event: true
        });
        this.wsCore.addEventListener(WebSocketEvent.NET_RESULT, (e) => this.wsResultHandler(e));
        break;
      case "error":
      case "close":
        Logger.log("Disconnected, try again.");
        this.wsCore.removeEventListener(WebSocketEvent.NET_RESULT);
        this.dispatchDisconnectEvent();
        break;
    }
  }
  wsResultHandler(event) {
    const eventResult = event.result;
    if (eventResult == null ? void 0 : eventResult.NetStatusEvent) {
      Logger.log("[NetStatusEvent]", eventResult);
      return;
    }
    if (eventResult == null ? void 0 : eventResult.action) {
      const eventParam = {
        eventName: `slotGameEvent_${eventResult.action}`,
        event: true
      };
      if (!eventResult.result) {
        this.dispatchConnectorEvent(eventParam);
        return;
      }
      if (eventResult.result.event == null) {
        if (eventResult.result.error != null && eventResult.result.error != "" || eventResult.result.falutCode != null) {
          eventParam.event = false;
        } else {
          eventParam.event = true;
        }
      } else {
        eventParam.event = eventResult.result.event;
      }
      if (eventResult.result.data == null) {
        eventParam.data = eventResult.result;
      } else {
        eventParam.data = eventResult.result.data;
      }
      this.dispatchConnectorEvent(eventParam);
    }
  }
  dispatchDisconnectEvent() {
    if (this.closeConnectionByUser) {
      UrlHelper.shared.exitGame();
      return;
    }
    this.showAlert("SYSTEM_BUSY_55670144");
  }
  dispatchConnectorEvent(eventObject) {
    this.getEventDispatcher().dispatchEvent(eventObject.eventName, {
      data: eventObject.data,
      event: eventObject.event
    });
    if (eventObject.event) {
      switch (eventObject.eventName) {
        case "slotGameEvent_ready" /* READY */:
          this.callLoginBySid();
          break;
        case "slotGameEvent_onTakeMachine" /* TAKE_MACHINE */:
          this.callLoadInfo();
          break;
      }
    } else {
      this.handleConnectorFailEvent(eventObject);
    }
  }
  handleConnectorFailEvent(eventObject) {
    var _a, _b, _c, _d;
    Logger.warn(`[SlotConnector] handleConnectorFailEvent [${eventObject.eventName}]`, eventObject.data);
    const errorDictString = ((_a = eventObject.data) == null ? void 0 : _a.error) || ((_b = eventObject.data) == null ? void 0 : _b.errCode) || "SYSTEM_BUSY_55670144";
    const errorId = (_c = eventObject.data) == null ? void 0 : _c.ErrorID;
    if (errorId) {
      switch (errorId) {
        case "5550000141":
        case "5554000510":
        case "5554000290":
          this.showAlert(`${CommonStore.shared.i18n["DUPLICATE_ERROR"]}\uFF08${errorDictString}\uFF09\uFF08${errorId}\uFF09`);
          break;
        default:
          this.showAlert(errorDictString);
          break;
      }
    } else {
      switch (eventObject.eventName) {
        case "slotGameEvent_onLogin" /* LOGIN */:
          this.showAlert(errorDictString);
          break;
        case "slotGameEvent_onTakeMachine" /* TAKE_MACHINE */:
          this.showAlert(errorDictString);
          break;
        case "slotGameEvent_onCreditExchange" /* CREDIT_EXCHANGE */:
          if (errorDictString !== "TRANSFER_FAILED") this.callGetMachineDetail();
          break;
        default:
          if (errorDictString === "ACCUMULATION_NOT_EXIST") {
            this.showAlert(`${CommonStore.shared.i18n[errorDictString]}\uFF08${(_d = eventObject.data) == null ? void 0 : _d.errCode}\uFF09`);
          } else {
            this.showAlert(errorDictString);
          }
          break;
      }
    }
  }
  showAlert(message) {
    useGlobalEventDispatcher().dispatchEvent(Comm.SHOW_ALERT, { message });
  }
  connect(wsHost) {
    return new Promise(async (resolve, reject) => {
      const wsPath = await UrlHelper.shared.getWsUrl(wsHost);
      Logger.log(`[SlotGameConnector] >> Start connect to :${wsPath} , sid:${UrlHelper.shared.sid} `);
      if (this.useEncryption) {
        this.wsCore.setupWs({
          useCrypto: new AESCrypto("OTNlODQ0YTkzNGQ3MWU4ODY3Yjg3NWI4NjVkN2U0ODcuODMwMGU1YjQ5MTdjMjhmNw")
        });
      }
      this.wsCore.connect(wsPath);
      this.getEventDispatcher().addEventListener("slotGameEvent_connected" /* CONNECTED */, () => resolve(), { once: true });
      this.getEventDispatcher().addEventListener("slotGameEvent_close" /* CLOSE */, () => reject(), { once: true });
    });
  }
  reconnect() {
    return new Promise(async (resolve, reject) => {
      this.wsCore.reconnect();
      this.getEventDispatcher().addEventListener("slotGameEvent_connected" /* CONNECTED */, () => resolve(), { once: true });
      this.getEventDispatcher().addEventListener("slotGameEvent_close" /* CLOSE */, () => reject(), { once: true });
    });
  }
  close() {
    this.callLeaveMachine();
    this.closeConnectionByUser = true;
    this.wsCore.close();
  }
  setupWs(param) {
    this.wsCore.setupWs(param);
    param.useEncryption !== void 0 && (this.useEncryption = param.useEncryption);
  }
  async awaitApiResult(eventName) {
    return await new Promise((resolve) => {
      this.getEventDispatcher().addEventListener(eventName, (e) => {
        resolve(e);
      }, { once: true });
    });
  }
  /** 遊戲資訊 */
  async callLoadInfo() {
    this.wsCore.callServer({
      action: "onLoadInfo2"
    });
    const result = await this.awaitApiResult("slotGameEvent_onOnLoadInfo2" /* LOAD_INFO */);
    LoadingInfo.shared.push(TimeLabelKeys.loadInfo);
    return result;
  }
  /** 登入 */
  async callLoginBySid() {
    const param = {
      action: "loginBySid",
      sid: UrlHelper.shared.sid,
      gtype: UrlHelper.shared.gameType,
      lang: UrlHelper.shared.lang,
      dInfo: DetectDevice.getDeviceInfo()
    };
    UrlHelper.shared.hallId && (param.hallID = UrlHelper.shared.hallId);
    UrlHelper.shared.userId && (param.userID = UrlHelper.shared.userId);
    this.wsCore.callServer(param);
    const result = await this.awaitApiResult("slotGameEvent_onLogin" /* LOGIN */);
    LoadingInfo.shared.push(TimeLabelKeys.login);
    return result;
  }
  async callGetMachineDetail() {
    LoadingInfo.shared.push(TimeLabelKeys.machineDetailStart);
    this.wsCore.callServer({
      action: "getMachineDetail"
    });
    const result = await this.awaitApiResult("slotGameEvent_onGetMachineDetail" /* GET_MACHINE_DETAIL */);
    LoadingInfo.shared.push(TimeLabelKeys.machineDetailEnd);
    return result;
  }
  async callLeaveMachine() {
    this.wsCore.callServer({
      action: "leaveMachine"
    });
    const result = await this.awaitApiResult("slotGameEvent_machineLeave" /* MACHINE_LEAVE */);
    LoadingInfo.shared.push(TimeLabelKeys.takeMachine);
    return result;
  }
  async callDoubleGame(wagersID) {
    this.wsCore.callServer({
      action: "doubleGame",
      sid: UrlHelper.shared.sid,
      wagersID
    });
    return this.awaitApiResult("slotGameEvent_onDoubleGame" /* DOUBLE_GAME */);
  }
  async callBeginGame(param) {
    this.wsCore.callServer({
      action: "beginGame4",
      ...param
    });
    return this.awaitApiResult("slotGameEvent_onBeginGame" /* BEGIN_GAME */);
  }
  async callCreditExchange(rate, credit) {
    this.wsCore.callServer({
      action: "creditExchange",
      rate,
      credit
    });
    return this.awaitApiResult("slotGameEvent_onCreditExchange" /* CREDIT_EXCHANGE */);
  }
  async callBalanceExchange() {
    this.wsCore.callServer({
      action: "balanceExchange"
    });
    return this.awaitApiResult("slotGameEvent_onBalanceExchange" /* BALANCE_EXCHANGE */);
  }
  async callKeepMachineStatus() {
    this.wsCore.callServer({
      action: "keepMachineStatus",
      sid: UrlHelper.shared.sid
    });
    return this.awaitApiResult("slotGameEvent_onKeepMachineStatus" /* KEEP_MACHINE_STATUS */);
  }
  async callEndGame(wagersID, creditEnd) {
    if (creditEnd != null) {
      this.dispatchConnectorEvent({
        eventName: "slotGameEvent_onEndGame" /* END_GAME */,
        event: true,
        data: { Credit: creditEnd }
      });
    } else {
      this.wsCore.callServer({
        action: "endGame",
        sid: UrlHelper.shared.sid,
        wagersID
      });
      return this.awaitApiResult("slotGameEvent_onEndGame" /* END_GAME */);
    }
  }
  callUpdateUserAnalysis(data) {
    this.wsCore.callServer({
      action: "updateUserAnalysis",
      data
    });
  }
  /** 儲存換分記錄 */
  callStoreExREcord(rec) {
    this.wsCore.callServer({
      action: "saveUserAutoExchange",
      exchangeRecord: rec
    });
  }
}

export { SlotGameConnector, SlotGameEvent };
//# sourceMappingURL=slotGameConnector.mjs.map
