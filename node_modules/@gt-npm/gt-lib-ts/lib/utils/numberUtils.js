'use strict';

function getRandomFloat(start, end) {
  return Math.random() * (end - start) + start;
}
function getRandomInt(start, end) {
  return Math.floor(Math.random() * (end - start + 1)) + start;
}
function getRandomArray(array, getCount) {
  let newArr = [];
  for (let i = 0; i < getCount; i++) {
    const item = array[Math.floor(Math.random() * array.length)];
    const index = array.indexOf(item);
    if (index > -1) {
      array.splice(index, 1);
      newArr.push(item);
    }
  }
  return newArr.sort((b, a) => {
    if (typeof a === "number" && typeof b === "number") {
      return b - a;
    }
    return 0;
  });
}
function thousandFormat(formatValue) {
  const valueStr = `${formatValue}`;
  if (isNaN(+valueStr)) {
    return valueStr;
  }
  const arr = valueStr.split(".");
  const re = /(\d{1,3})(?=(\d{3})+$)/g;
  const num = arr[0].replace(re, "$1,") + (arr.length === 2 ? `.${arr[1]}` : "");
  return num;
}
function pointFormat(formatValue, roundCount, type = "floor") {
  const valueStr = `${formatValue}`;
  if (isNaN(+valueStr)) {
    return valueStr;
  }
  const slice = valueStr.split(".");
  if (slice.length === 1) {
    return `${valueStr}${roundCount ? `.${"0".repeat(roundCount)}` : ""}`;
  }
  const decimalLength = slice[1].length;
  const lengthDiff = roundCount - decimalLength;
  if (!lengthDiff) {
    return valueStr;
  }
  if (lengthDiff > 0) {
    return `${valueStr}${"0".repeat(lengthDiff)}`;
  }
  let floorString = valueStr.slice(0, lengthDiff);
  if (type === "round") {
    const checkNum = valueStr.slice(lengthDiff, lengthDiff + 1 || void 0);
    floorString = +checkNum >= 5 ? (+`${floorString}51`).toFixed(roundCount) : floorString;
  }
  return roundCount ? floorString : floorString.replace(".", "");
}
function formatNumber(param) {
  const { formatValue, roundCount, thousandth, keepDecimal, isKFormat, decimalType = "floor" } = param;
  const valueNum = +formatValue;
  if (isNaN(valueNum)) return `${formatValue}`;
  let calcValue = valueNum;
  let kSymbol = "";
  if (isKFormat && valueNum >= 1e5) {
    calcValue = accMul(valueNum, 1e-3);
    kSymbol = "K";
  }
  if (roundCount !== void 0) {
    calcValue = pointFormat(calcValue, roundCount, decimalType);
    calcValue = keepDecimal ? calcValue : +calcValue;
  }
  const thousandthValue = thousandth ? thousandFormat(calcValue) : `${calcValue}`;
  return `${thousandthValue}${kSymbol}`;
}
function accMul(arg1, arg2) {
  var _a, _b, _c, _d;
  const arg1Str = `${arg1}`;
  const arg2Str = `${arg2}`;
  let pow = 0;
  pow += (_b = (_a = arg1Str.split(".")[1]) == null ? void 0 : _a.length) != null ? _b : 0;
  pow += (_d = (_c = arg2Str.split(".")[1]) == null ? void 0 : _c.length) != null ? _d : 0;
  const r1 = +arg1Str.replace(".", "");
  const r2 = +arg2Str.replace(".", "");
  return r1 * r2 / 10 ** pow;
}
function accDiv(arg1, arg2) {
  var _a, _b, _c, _d;
  const arg1Str = `${arg1}`;
  const arg2Str = `${arg2}`;
  const t1 = (_b = (_a = arg1Str.split(".")[1]) == null ? void 0 : _a.length) != null ? _b : 0;
  const t2 = (_d = (_c = arg2Str.split(".")[1]) == null ? void 0 : _c.length) != null ? _d : 0;
  const r1 = +arg1Str.replace(".", "");
  const r2 = +arg2Str.replace(".", "");
  return accMul(r1 / r2, +`1e${t2 - t1}`);
}
function accAdd(arg1, arg2) {
  let r1 = 0;
  let r2 = 0;
  let m;
  try {
    r1 = arg1.toString().split(".")[1].length;
  } catch (e) {
  }
  try {
    r2 = arg2.toString().split(".")[1].length;
  } catch (e) {
  }
  m = Math.pow(10, Math.max(r1, r2));
  return (accMul(arg1, m) + accMul(arg2, m)) / m;
}
function accSub(arg1, arg2) {
  return accAdd(arg1, -arg2);
}

exports.accAdd = accAdd;
exports.accDiv = accDiv;
exports.accMul = accMul;
exports.accSub = accSub;
exports.formatNumber = formatNumber;
exports.getRandomArray = getRandomArray;
exports.getRandomFloat = getRandomFloat;
exports.getRandomInt = getRandomInt;
exports.pointFormat = pointFormat;
exports.thousandFormat = thousandFormat;
//# sourceMappingURL=numberUtils.js.map
