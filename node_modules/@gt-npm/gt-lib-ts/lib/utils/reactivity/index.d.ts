import { Ref, ComputedRef, ComputedGetter, DebuggerOptions, WritableComputedRef, ReactiveEffectOptions, WritableComputedOptions, ReactiveEffectRunner } from './vue-reactivity';
export { ref, toRef, toRefs, toRaw, triggerRef, isReadonly, reactive, customRef, deferredComputed, effectScope, enableTracking, getCurrentScope, isProxy, isReactive, isRef, isShallow, ITERATE_KEY, markRaw, onScopeDispose, pauseTracking, proxyRefs, readonly, resetTracking, shallowReactive, shallowReadonly, track, trigger, unref, stop } from './vue-reactivity';
export type { ComputedRef, Ref, ComputedGetter, ComputedSetter, CustomRefFactory, DebuggerEvent, DebuggerEventExtraInfo, DebuggerOptions, DeepReadonly, EffectScheduler, EffectScope, Raw, ReactiveEffect, ReactiveEffectOptions, ReactiveEffectRunner, RefUnwrapBailTypes, ShallowReactive, ShallowRef, ShallowUnwrapRef, ToRef, ToRefs, UnwrapNestedRefs, UnwrapRef, WritableComputedOptions, WritableComputedRef } from './vue-reactivity';
type WatchSource<T = any> = Ref<T> | ComputedRef<T> | (() => T);
type WatchCallback<V = any, OV = any> = (value: V, oldValue: OV) => any;
type MapSources<T, Immediate> = {
    [K in keyof T]: T[K] extends WatchSource<infer V> ? Immediate extends true ? V | undefined : V : T[K] extends object ? Immediate extends true ? T[K] | undefined : T[K] : never;
};
interface WatchOptions<Immediate = boolean> extends DebuggerOptions {
    immediate?: Immediate;
    deep?: boolean;
    fixed?: boolean;
}
export type WatchStopHandle = () => void;
export type DisposeCallback = WatchStopHandle | ((disposeBag?: WatchStopHandle[]) => void);
type MultiWatchSources = (WatchSource<unknown> | object)[];
export declare function createDisposeBag(): WatchStopHandle[];
export declare function disWatch(disposeBag: WatchStopHandle[]): void;
export declare function watch<T extends MultiWatchSources, Immediate extends Readonly<boolean> = false>(sources: [...T], cb: WatchCallback<MapSources<T, false>, MapSources<T, Immediate>>, options?: WatchOptions<Immediate>): DisposeCallback;
export declare function watch<T extends Readonly<MultiWatchSources>, Immediate extends Readonly<boolean> = false>(source: T, cb: WatchCallback<MapSources<T, false>, MapSources<T, Immediate>>, options?: WatchOptions<Immediate>): DisposeCallback;
export declare function watch<T, Immediate extends Readonly<boolean> = false>(source: WatchSource<T>, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: WatchOptions<Immediate>): DisposeCallback;
export declare function watch<T extends object, Immediate extends Readonly<boolean> = false>(source: T, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: WatchOptions<Immediate>): DisposeCallback;
export declare const watchFixed: typeof watch;
export declare function awaitRefChanged<T>(refValue: Ref<T>): Promise<{
    newValue: T;
    oldValue: T;
}>;
export declare function computed<T>(getter: ComputedGetter<T>, debugOptions?: DebuggerOptions & {
    fixed?: boolean;
}): ComputedRef<T>;
export declare function computed<T>(options: WritableComputedOptions<T>, debugOptions?: DebuggerOptions & {
    fixed?: boolean;
}): WritableComputedRef<T>;
export declare const computedFixed: typeof computed;
export declare function effect<T = any>(fn: () => T, options?: ReactiveEffectOptions & {
    fixed?: boolean;
}): ReactiveEffectRunner;
export declare const effectFixed: typeof effect;
