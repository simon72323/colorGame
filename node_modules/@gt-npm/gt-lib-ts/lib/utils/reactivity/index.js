'use strict';

var urlUtils = require('../urlUtils.js');
var vueReactivity = require('./vue-reactivity.js');

var _a, _b, _c, _d;
const __DEVELOPMENT__ = urlUtils.getUrlQuery("isDev") === "true";
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const isArray = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isFunction = (val) => typeof val === "function";
const isObject = (val) => val !== null && typeof val === "object";
const isPlainObject = (val) => toTypeString(val) === "[object Object]";
const isPromise = (val) => isObject(val) && isFunction(val.then) && isFunction(val.catch);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const EMPTY_OBJ = __DEVELOPMENT__ ? Object.freeze({}) : {};
const NOOP = () => {
};
const INITIAL_WATCHER_VALUE = {};
const ErrorCodes = {
  WATCH_GETTER: "watcher getter",
  WATCH_CALLBACK: "watcher callback",
  WATCH_CLEANUP: "watcher cleanup function"
};
function callWithErrorHandling(fn, type, args) {
  let res;
  try {
    res = args ? fn(...args) : fn();
  } catch (err) {
    console.warn(type, err);
  }
  return res;
}
function callWithAsyncErrorHandling(fn, type, args) {
  if (isFunction(fn)) {
    const res = callWithErrorHandling(fn, type, args);
    if (res && isPromise(res)) {
      res.catch((err) => {
        console.warn(err);
      });
    }
    return res;
  }
  const values = [];
  for (let i = 0; i < fn.length; i++) {
    values.push(callWithAsyncErrorHandling(fn[i], type, args));
  }
  return values;
}
function createDisposeBag() {
  return [];
}
function disWatch(disposeBag) {
  var _a2;
  while (disposeBag.length) {
    (_a2 = disposeBag.pop()) == null ? void 0 : _a2();
  }
}
function watch(source, cb, options) {
  return doWatch(source, cb, options);
}
const watchFixed = function(source, cb, options = {}) {
  return watch(source, cb, {
    ...options,
    fixed: true
  });
};
function awaitRefChanged(refValue) {
  return new Promise((resolve) => {
    const clearWatch = watch(refValue, (newValue, oldValue) => {
      resolve({
        newValue,
        oldValue
      });
      clearWatch();
    });
  });
}
function doWatch(source, cb, { immediate, deep: _deep, onTrack, onTrigger, fixed } = EMPTY_OBJ) {
  var _a2, _b2, _c2, _d2;
  let deep = _deep;
  const warnInvalidSource = (s) => {
    console.warn(
      "Invalid watch source: ",
      s,
      "A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types."
    );
  };
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  let effect2;
  if (vueReactivity.isRef(source)) {
    getter = () => source.value;
    forceTrigger = vueReactivity.isShallow(source);
  } else if (vueReactivity.isReactive(source)) {
    getter = () => source;
    deep = true;
  } else if (isArray(source)) {
    isMultiSource = true;
    forceTrigger = source.some(vueReactivity.isReactive);
    getter = () => source.map((s) => {
      if (vueReactivity.isRef(s)) {
        return s.value;
      } else if (vueReactivity.isReactive(s)) {
        return traverse(s);
      } else if (isFunction(s)) {
        return callWithErrorHandling(s, ErrorCodes.WATCH_GETTER);
      } else {
        __DEVELOPMENT__ && warnInvalidSource(s);
      }
    });
  } else if (isFunction(source)) {
    getter = () => callWithErrorHandling(source, ErrorCodes.WATCH_GETTER);
  } else {
    getter = NOOP;
    __DEVELOPMENT__ && warnInvalidSource(source);
  }
  if (deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onInvalidate = (fn) => {
    cleanup = effect2.onStop = () => {
      callWithErrorHandling(fn, ErrorCodes.WATCH_CLEANUP);
    };
  };
  let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect2.active) {
      return;
    }
    if (cb) {
      const newValue = effect2.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb, ErrorCodes.WATCH_CALLBACK, [
          newValue,
          // pass undefined as the old value when it's changed for the first time
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : oldValue,
          onInvalidate
        ]);
        oldValue = newValue;
      }
    } else {
      effect2.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler = job;
  const effectScope2 = fixed ? (_b2 = (_a2 = window.gtLibTsScope) == null ? void 0 : _a2.fixedScope) == null ? void 0 : _b2.effectScope : (_d2 = (_c2 = window.gtLibTsScope) == null ? void 0 : _c2.globalScope) == null ? void 0 : _d2.effectScope;
  effect2 = new vueReactivity.ReactiveEffect(getter, scheduler, effectScope2);
  if (__DEVELOPMENT__) {
    effect2.onTrack = onTrack;
    effect2.onTrigger = onTrigger;
  }
  if (immediate) {
    job();
  } else {
    oldValue = effect2.run();
  }
  return (disposeBag) => {
    if (disposeBag) {
      disposeBag.push(() => {
        effect2.stop();
      });
    } else {
      effect2.stop();
    }
  };
}
function traverse(value, _seen) {
  if (!isObject(value) || value["__v_skip"]) {
    return value;
  }
  const seen = _seen || /* @__PURE__ */ new Set();
  if (seen.has(value)) {
    return value;
  }
  seen.add(value);
  if (vueReactivity.isRef(value)) {
    traverse(value.value, seen);
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], seen);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v) => {
      traverse(v, seen);
    });
  } else if (isPlainObject(value)) {
    Object.keys(value).forEach((key) => {
      traverse(value[key], seen);
    });
  }
  return value;
}
function computed(optionsOrGetter, debugOptions) {
  var _a2, _b2, _c2, _d2;
  const computedResult = vueReactivity.computed(optionsOrGetter, debugOptions);
  const disposeBag = (debugOptions == null ? void 0 : debugOptions.fixed) ? (_b2 = (_a2 = window.gtLibTsScope) == null ? void 0 : _a2.fixedScope) == null ? void 0 : _b2.disposeBag : (_d2 = (_c2 = window.gtLibTsScope) == null ? void 0 : _c2.globalScope) == null ? void 0 : _d2.disposeBag;
  disposeBag == null ? void 0 : disposeBag.push(() => {
    computedResult.effect.stop();
  });
  return computedResult;
}
const computedFixed = function(optionsOrGetter, debugOptions) {
  return computed(optionsOrGetter, {
    ...debugOptions,
    fixed: true
  });
};
function effect(fn, options) {
  var _a2, _b2, _c2, _d2;
  const effectResult = vueReactivity.effect(fn, options);
  const disposeBag = (options == null ? void 0 : options.fixed) ? (_b2 = (_a2 = window.gtLibTsScope) == null ? void 0 : _a2.fixedScope) == null ? void 0 : _b2.disposeBag : (_d2 = (_c2 = window.gtLibTsScope) == null ? void 0 : _c2.globalScope) == null ? void 0 : _d2.disposeBag;
  disposeBag == null ? void 0 : disposeBag.push(() => {
    effectResult.effect.stop();
  });
  return effectResult;
}
const effectFixed = function(fn, options = {}) {
  return effect(fn, {
    ...options,
    fixed: true
  });
};
if (!((_a = window.gtLibTsScope) == null ? void 0 : _a.fixedScope)) {
  ((_b = window.gtLibTsScope) != null ? _b : window.gtLibTsScope = {}).fixedScope = {
    effectScope: new vueReactivity.EffectScope(),
    disposeBag: []
  };
}
if (!((_c = window.gtLibTsScope) == null ? void 0 : _c.fixedScope)) {
  ((_d = window.gtLibTsScope) != null ? _d : window.gtLibTsScope = {}).fixedScope = {
    effectScope: new vueReactivity.EffectScope(),
    disposeBag: []
  };
}

exports.ITERATE_KEY = vueReactivity.ITERATE_KEY;
exports.customRef = vueReactivity.customRef;
exports.deferredComputed = vueReactivity.deferredComputed;
exports.effectScope = vueReactivity.effectScope;
exports.enableTracking = vueReactivity.enableTracking;
exports.getCurrentScope = vueReactivity.getCurrentScope;
exports.isProxy = vueReactivity.isProxy;
exports.isReactive = vueReactivity.isReactive;
exports.isReadonly = vueReactivity.isReadonly;
exports.isRef = vueReactivity.isRef;
exports.isShallow = vueReactivity.isShallow;
exports.markRaw = vueReactivity.markRaw;
exports.onScopeDispose = vueReactivity.onScopeDispose;
exports.pauseTracking = vueReactivity.pauseTracking;
exports.proxyRefs = vueReactivity.proxyRefs;
exports.reactive = vueReactivity.reactive;
exports.readonly = vueReactivity.readonly;
exports.ref = vueReactivity.ref;
exports.resetTracking = vueReactivity.resetTracking;
exports.shallowReactive = vueReactivity.shallowReactive;
exports.shallowReadonly = vueReactivity.shallowReadonly;
exports.stop = vueReactivity.stop;
exports.toRaw = vueReactivity.toRaw;
exports.toRef = vueReactivity.toRef;
exports.toRefs = vueReactivity.toRefs;
exports.track = vueReactivity.track;
exports.trigger = vueReactivity.trigger;
exports.triggerRef = vueReactivity.triggerRef;
exports.unref = vueReactivity.unref;
exports.awaitRefChanged = awaitRefChanged;
exports.computed = computed;
exports.computedFixed = computedFixed;
exports.createDisposeBag = createDisposeBag;
exports.disWatch = disWatch;
exports.effect = effect;
exports.effectFixed = effectFixed;
exports.watch = watch;
exports.watchFixed = watchFixed;
//# sourceMappingURL=index.js.map
